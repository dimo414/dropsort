"""Utility functions for benchmarking dropsort algorithms
"""

from collections import Counter, defaultdict, OrderedDict

import dropsort, util

def compute_retained_ratio(f, *,
    min_size=10,
    max_size=100,
    iters=10000,
    shuffle=util.full_shuffle,
    ls_gen=lambda n: list(range(n))):
  """Computes the retainment rate of a given function that takes a list and
  and returns a subset of the list's elements.

  For sizes "n" between `min_size` and `max_size`, inclusive, invokes `f`
  `iters` times on lists of size "n" generated by `ls_gen` and shuffled by
  `shuffle`, then computes the ratio of the size of the result to the input
  size.

  Returns a dictionary mapping list sizes to the retained ratio for that size.
  """
  retained = Counter()
  for size in range(min_size, max_size + 1):
    for _ in range(iters):
      ls = shuffle(ls_gen(size))
      retained[size] += len(f(ls))

  return OrderedDict((k, v/k/iters) for k, v in retained.items())

def compute_parameterized_retained_ratio(f, min_n=10, max_n=100, **kwargs):
  """Computes the retainment rate of a given function that takes a list and a n.

  Invokes compute_retained_ratio once for each value between `min_range` and
  `max_range`, storing the results in a 2D array. The first key is a given `n`,
  the inner dictionary is the result of invoking compute_retained_ratio on a
  curried version of `f` that uses the given value of `n`.
  """
  ratios = OrderedDict()
  for n in range(min_n, max_n + 1):
    def f_n(ls):
      return f(ls, n)
    f_n.__name__ = '%s:n=%d' % (f.__name__, n)
    ratios[n] = compute_retained_ratio(f_n, **kwargs)
  return ratios
